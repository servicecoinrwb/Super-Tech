<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Tech: Service Run</title>
    <link rel="icon" href="https://imageview.mechanicaltemp.com/objects/uploads/d4641033-922a-45e1-bd01-2d5c74b8ecd2">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #222;
            --text-color: #fff;
            --primary-color: #3498db;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --warning-color: #f1c40f;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 100%;
        }

        /* --- UI OVERLAYS --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            text-shadow: 2px 2px 0 #000;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            pointer-events: auto;
        }

        .hud-stats { display: flex; flex-direction: column; gap: 8px; font-size: 14px; }
        .hud-controls { display: flex; gap: 10px; }

        /* Fuel Bar */
        #fuel-container { width: 150px; }
        .fuel-label { font-size: 10px; color: #ccc; margin-bottom: 3px; }
        .fuel-track { width: 100%; height: 12px; border: 2px solid white; background: #333; }
        .fuel-fill { width: 100%; height: 100%; background-color: var(--success-color); transition: width 0.1s; }
        .fuel-fill.low { background-color: var(--danger-color); animation: blink 0.5s infinite; }

        /* Screens */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); /* Slightly transparent to see game behind */
            display: flex; flex-direction: column;
            justify-content: flex-start; /* Changed from center to handle tall content */
            align-items: center;
            text-align: center; 
            pointer-events: auto; 
            z-index: 30;
            overflow-y: auto; /* Allow scrolling if leaderboard is long */
            padding-top: 40px;
            padding-bottom: 40px;
            box-sizing: border-box;
        }
        
        .hidden { display: none !important; opacity: 0; pointer-events: none; }

        #screen-level { justify-content: center; background: rgba(26, 11, 46, 0.95); pointer-events: none; }
        #screen-gameover { justify-content: center; }
        #screen-win { justify-content: center; background: rgba(46, 204, 113, 0.95); }

        h1 { font-size: 28px; color: var(--warning-color); text-shadow: 4px 4px 0 #8B4500; margin-bottom: 15px; line-height: 1.4; }
        .ninja-title { color: #e74c3c !important; text-shadow: 4px 4px 0 #000 !important; font-style: italic; }

        .logo-img {
            max-width: 250px; width: 70%; height: auto; margin-bottom: 15px;
            image-rendering: pixelated; filter: contrast(1.2) brightness(1.1);
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.2));
        }

        p { font-size: 12px; line-height: 20px; color: #ccc; max-width: 600px; margin: 0 auto 15px; padding: 0 20px; }

        /* Buttons */
        .btn-retro {
            background: var(--danger-color);
            border: 4px solid #c0392b;
            color: white;
            font-family: inherit;
            font-size: 16px;
            padding: 12px 24px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 6px 0 #962d22;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .btn-retro:active { transform: translateY(6px); box-shadow: 0 0 0 #962d22; }
        .btn-secondary { background: #7f8c8d; border-color: #555; box-shadow: 0 6px 0 #333; }
        
        .btn-google {
            background: #fff;
            color: #333;
            border: none;
            font-family: sans-serif;
            font-weight: bold;
            font-size: 13px;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        .btn-google:active { background: #eee; }
        
        .btn-icon {
            background: rgba(255,255,255,0.1);
            border: 2px solid white;
            color: white;
            font-family: inherit;
            width: 40px; height: 40px;
            cursor: pointer;
            font-size: 16px;
            display: flex; align-items: center; justify-content: center;
        }
        .btn-icon:hover { background: rgba(255,255,255,0.3); }

        /* Leaderboard Styles */
        #leaderboard {
            margin-top: 15px;
            background: rgba(0,0,0,0.6);
            border: 2px solid #3498db;
            padding: 10px;
            width: 90%;
            max-width: 320px;
            max-height: 180px;
            overflow-y: auto;
            font-size: 10px;
            text-align: left;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.3);
        }
        .leaderboard-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            border-bottom: 1px dotted #555;
            padding-bottom: 3px;
        }
        .leaderboard-row:last-child { border-bottom: none; }
        .rank-name { color: #f1c40f; }
        .rank-score { color: #2ecc71; }

        #input-container { margin: 15px 0; }
        #username, #win-username {
            background: #333;
            border: 2px solid #fff;
            color: #fff;
            padding: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            text-transform: uppercase;
            text-align: center;
            width: 150px;
        }
        
        #user-status {
            font-size: 10px;
            color: #aaa;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Enabled via JS based on screen size */
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 40; pointer-events: none;
        }
        .touch-zone {
            pointer-events: auto;
            position: absolute; bottom: 30px;
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: white;
            backdrop-filter: blur(4px);
            user-select: none;
        }
        .touch-zone:active { background: rgba(255, 255, 255, 0.3); transform: scale(0.95); }
        
        #dpad-left { left: 20px; }
        #dpad-right { left: 110px; }
        #dpad-up { left: 65px; bottom: 90px; display: none; } 
        #dpad-down { left: 65px; bottom: 20px; display: none; } 
        
        #btn-action { 
            right: 30px; width: 90px; height: 90px; 
            border-color: var(--danger-color); color: var(--danger-color);
            background: rgba(231, 76, 60, 0.15);
            font-size: 14px; font-weight: bold;
        }

        /* Animations */
        @keyframes blink { 50% { opacity: 0.5; } }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: #222; }
        ::-webkit-scrollbar-thumb { background: #555; }
        ::-webkit-scrollbar-thumb:hover { background: #888; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="ui-layer">
        <div class="hud-panel">
            <div class="hud-stats">
                <div id="hud-score">CASH: $0</div>
                <div id="hud-time" style="color: var(--warning-color);">SHIFT: 00:00</div>
                <div id="fuel-container">
                    <div class="fuel-label">FUEL</div>
                    <div class="fuel-track"><div id="fuel-fill" class="fuel-fill"></div></div>
                </div>
            </div>
            <div class="hud-controls">
                <button class="btn-icon" id="btn-music">♫</button>
                <button class="btn-icon" id="btn-menu">☰</button>
            </div>
        </div>
        
        <!-- Mobile Controls Overlay -->
        <div id="mobile-controls">
            <div id="dpad-left" class="touch-zone">◄</div>
            <div id="dpad-right" class="touch-zone">►</div>
            <div id="dpad-up" class="touch-zone">▲</div>
            <div id="dpad-down" class="touch-zone">▼</div>
            <div id="btn-action" class="touch-zone">ACT</div>
        </div>
    </div>

    <!-- SCREENS -->
    <div id="screen-start" class="screen">
        <img src="https://imageview.mechanicaltemp.com/objects/uploads/b06a602d-a276-47bc-808e-585ada089aa4" alt="Mechanical Temp" class="logo-img">
        <h1>SUPER TECH</h1>
        <p>Drive the service van, fix HVACs, and dodge traffic!</p>
        
        <button class="btn-retro" onclick="window.startGame()">START ENGINE</button>
        
        <button id="btn-google-login" class="btn-google" onclick="window.loginGoogle()">
            <span style="font-weight:900;">G</span> Sign in for Leaderboard
        </button>
        <div id="user-status">Not Signed In</div>
        
        <div id="leaderboard">
            <div style="text-align:center; color:#3498db; margin-bottom:10px; border-bottom: 2px solid #3498db; padding-bottom:5px; font-size:10px;">TOP TECHNICIANS</div>
            <div id="leaderboard-list">Loading...</div>
        </div>
    </div>

    <div id="screen-level" class="screen hidden">
        <h1 id="level-title" style="color: var(--danger-color);">LEVEL 2</h1>
        <h1 id="level-subtitle" style="font-size: 40px; margin-top: -10px;">ON CALL</h1>
        <p id="level-desc">NIGHT SHIFT BEGINS</p>
    </div>

    <div id="screen-gameover" class="screen hidden">
        <h1>GAME OVER</h1>
        <p id="end-reason" style="color: var(--danger-color);">CRASHED!</p>
        <p id="end-score">EARNINGS: $0</p>
        <p style="font-size:10px; color:#aaa; margin-top:-10px;">(HIGH SCORE: $<span id="local-high-score">0</span>)</p>
        
        <div id="input-container">
            <input type="text" id="username" placeholder="AAA" maxlength="3">
        </div>
        <button class="btn-retro" onclick="window.submitScore()">SUBMIT SCORE</button>
        <button class="btn-retro btn-secondary" onclick="window.resetGame()">SKIP & RESTART</button>
    </div>
    
    <div id="screen-win" class="screen hidden" style="background: rgba(39, 174, 96, 0.95);">
        <h1>MISSION COMPLETE</h1>
        <p>You reached the Master Chiller!</p>
        <p id="win-score" style="font-size: 24px; color: gold;">$0</p>
        <div id="win-input-container" style="margin: 15px 0;">
             <input type="text" id="win-username" placeholder="AAA" maxlength="3">
        </div>
        <button class="btn-retro" onclick="window.submitWinScore()">SUBMIT & RETURN</button>
    </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, GoogleAuthProvider, signInWithPopup, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, collection, addDoc, getDocs, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// --- FIREBASE SETUP ---
const userFirebaseConfig = {
  apiKey: "AIzaSyAjvlIYsfGhyBf7k7Z-MSj2LH73eOE3P0E",
  authDomain: "super-tech-484616.firebaseapp.com",
  projectId: "super-tech-484616",
  storageBucket: "super-tech-484616.firebasestorage.app",
  messagingSenderId: "942029806104",
  appId: "1:942029806104:web:71d24eb2fa675cf9c9c16d",
  measurementId: "G-LK5824QF4D"
};

const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : userFirebaseConfig;
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

let leaderboardData = [];
let currentUser = null;

async function initFirebase() {
    onAuthStateChanged(auth, (user) => {
        currentUser = user;
        if (user) {
            let name = user.displayName || 'Anonymous';
            if(name.length > 10) name = name.substring(0,10) + '...';
            document.getElementById('user-status').innerText = `Tech: ${name}`;
            if(user.displayName) {
                document.getElementById('btn-google-login').style.display = 'none';
            }
            loadLeaderboard();
        } else {
            signInAnonymously(auth).catch(e => {
                console.error("Anon Auth Failed:", e);
                const status = document.getElementById('user-status');
                if (e.code === 'auth/admin-restricted-operation') {
                    status.innerText = "Leaderboard: Offline (Auth Config)";
                    status.style.color = "#e74c3c";
                    document.getElementById('leaderboard-list').innerHTML = "<div>Scores Offline</div>";
                } else {
                    status.innerText = "Auth Failed";
                }
            });
        }
    });
}

window.loginGoogle = async () => {
    const provider = new GoogleAuthProvider();
    try {
        await signInWithPopup(auth, provider);
    } catch (error) {
        console.error("Google Sign-In Error", error);
        alert("Sign-in failed. Popup might be blocked.");
    }
};

async function loadLeaderboard() {
    const list = document.getElementById('leaderboard-list');
    list.innerHTML = "Loading...";
    
    try {
        const q = query(collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard'));
        const snapshot = await getDocs(q);
        
        let scores = [];
        snapshot.forEach(doc => scores.push(doc.data()));
        
        scores.sort((a, b) => b.score - a.score);
        leaderboardData = scores.slice(0, 10); 
        
        renderLeaderboard();
    } catch (e) {
        console.error("Fetch failed", e);
        list.innerHTML = "<div style='padding:10px;'>Leaderboard Offline</div>";
    }
}

function renderLeaderboard() {
    const list = document.getElementById('leaderboard-list');
    list.innerHTML = "";
    
    if (leaderboardData.length === 0) {
        list.innerHTML = "<div style='padding:10px;'>No records yet.</div>";
        return;
    }
    
    leaderboardData.forEach((entry, index) => {
        const row = document.createElement('div');
        row.className = 'leaderboard-row';
        row.innerHTML = `
            <span class="rank-name">${index + 1}. ${entry.name}</span>
            <span class="rank-score">$${entry.score}</span>
        `;
        list.appendChild(row);
    });
}

async function saveScore(name, score) {
    const localHigh = localStorage.getItem('hvac_high_score') || 0;
    if (score > localHigh) localStorage.setItem('hvac_high_score', score);

    if (!auth.currentUser) return;
    
    let finalName = name || (currentUser.displayName ? currentUser.displayName.substring(0,3).toUpperCase() : "UNK");
    if(finalName.length > 3) finalName = finalName.substring(0, 3).toUpperCase();
    
    const entry = {
        name: finalName,
        score: parseInt(score),
        date: new Date().toISOString(),
        uid: currentUser.uid
    };
    
    try {
        await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard'), entry);
        await loadLeaderboard();
    } catch (e) {
        console.error("Save failed", e);
    }
}

// --- CONFIGURATION ---
const Config = {
    RoadWidth: 400,
    TotalViewWidth: 700, 
    BaseSpeed: 300,
    MaxSpeedLvl1: 800,
    MaxSpeedLvl2: 1000,
    FuelRateLvl1: 5,
    FuelRateLvl2: 7,
    Earnings: { Fix: 50, RefuelCost: 100, Bonus: 250, EnemyKill: 100 },
    Colors: { GrassDay: '#2c3e50', GrassNight: '#1a0b2e', RoadDay: '#7f8c8d', RoadNight: '#34495e' }
};

// --- SYSTEM: INPUT ---
const Input = {
    keys: { ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false, Space: false },
    init() {
        window.addEventListener('keydown', e => this.handleKey(e.code, true));
        window.addEventListener('keyup', e => this.handleKey(e.code, false));
        this.bindTouch('dpad-left', 'ArrowLeft');
        this.bindTouch('dpad-right', 'ArrowRight');
        this.bindTouch('dpad-up', 'ArrowUp');
        this.bindTouch('dpad-down', 'ArrowDown');
        this.bindTouch('btn-action', 'Space');
        this.checkMobile();
        window.addEventListener('resize', () => this.checkMobile());
    },
    handleKey(code, isDown) {
        if (this.keys.hasOwnProperty(code)) {
            if(code === 'Space' && isDown && this.keys.Space) return;
            this.keys[code] = isDown;
            if(code === 'Space' && isDown && Game.scene) Game.scene.onAction();
        }
    },
    bindTouch(id, code) {
        const el = document.getElementById(id);
        if(!el) return;
        el.addEventListener('touchstart', (e) => { e.preventDefault(); this.handleKey(code, true); });
        el.addEventListener('touchend', (e) => { e.preventDefault(); this.handleKey(code, false); });
    },
    checkMobile() {
        const isMobile = window.innerWidth < 900 || ('ontouchstart' in window);
        document.getElementById('mobile-controls').style.display = isMobile ? 'block' : 'none';
        if(Game.scene instanceof DrivingScene) {
             document.getElementById('dpad-up').style.display = 'flex';
             document.getElementById('dpad-down').style.display = 'flex';
        } else if (Game.scene instanceof PlatformerScene) {
             document.getElementById('dpad-up').style.display = 'flex';
             document.getElementById('dpad-down').style.display = 'none';
        }
    }
};

// --- SYSTEM: AUDIO ---
const Audio = {
    ctx: null, muted: false, timer: null, beat: 0, tempo: 107,
    init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
    toggleMute() { this.muted = !this.muted; if(this.muted) this.stopMusic(); else this.startMusic(); },
    startMusic(bpm = 107) {
        if(this.muted) return;
        this.init();
        if(this.ctx.state === 'suspended') this.ctx.resume();
        this.stopMusic();
        this.beat = 0; this.tempo = bpm;
        this.timer = setInterval(() => this.playBeat(), this.tempo);
    },
    stopMusic() { if(this.timer) clearInterval(this.timer); },
    playBeat() {
        if(!this.ctx || this.muted) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination); osc.type = 'sawtooth';
        
        const notes = [82.41, 82.41, 82.41, 82.41, 98.00, 82.41, 110.00, 98.00]; 
        let freq = notes[this.beat % 8];
        if(Game.level >= 2) freq *= 1.122; 
        
        osc.frequency.setValueAtTime(freq, t);
        gain.gain.setValueAtTime(0.15, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        osc.start(t); osc.stop(t + 0.1);

        if (this.beat % 4 === 0) {
            const kOsc = this.ctx.createOscillator(); const kGain = this.ctx.createGain();
            kOsc.connect(kGain); kGain.connect(this.ctx.destination);
            kOsc.frequency.setValueAtTime(150, t); kOsc.frequency.exponentialRampToValueAtTime(0.01, t + 0.1);
            kGain.gain.setValueAtTime(0.4, t); kGain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
            kOsc.start(t); kOsc.stop(t + 0.1);
        }
        this.beat++;
    },
    sfx(type) {
        if(!this.ctx || this.muted) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);

        if (type === 'jump' || type === 'throw') {
            osc.type = 'square'; osc.frequency.setValueAtTime(200, t); osc.frequency.linearRampToValueAtTime(400, t + 0.1);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.1);
            osc.start(t); osc.stop(t + 0.1);
        } else if (type === 'crash') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(10, t + 0.3);
            gain.gain.setValueAtTime(0.2, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
            osc.start(t); osc.stop(t + 0.3);
        } else if (type === 'score') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(600, t); osc.frequency.setValueAtTime(1200, t + 0.1);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.3);
            osc.start(t); osc.stop(t + 0.3);
        } else if (type === 'levelup') {
            osc.type = 'square'; osc.frequency.setValueAtTime(440, t); osc.frequency.setValueAtTime(880, t + 0.5);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0.0, t + 1.0);
            osc.start(t); osc.stop(t + 1.0);
        }
    }
};

// --- BASE CLASSES ---
class Entity {
    constructor(x, y, w, h) { this.x = x; this.y = y; this.width = w; this.height = h; this.active = true; }
}

// --- SCENE: DRIVING ---
class DrivingScene {
    constructor(level) {
        this.level = level;
        this.player = { x: 0, y: 0, width: 40, height: 70 };
        this.entities = [];
        this.speed = Config.BaseSpeed;
        this.distance = 0; 
        this.hazardTimer = 0;
        this.envTimer = 0;
        
        document.getElementById('fuel-container').style.display = 'block';
        Input.checkMobile(); 
        
        // Setup initial render for menu "Attract Mode" logic (if needed)
        // But for actual gameplay, we start fresh.
    }

    onAction() {
        const playerY = Game.canvas.height - 100 - this.player.y;
        let acted = false;
        this.entities.forEach(e => {
            if (Math.abs(e.y - playerY) < 120) {
                const aligned = (e.side === -1 && this.player.x < -50) || (e.side === 1 && this.player.x > 50);
                if (aligned) {
                    if (e.type === 'house' && e.needsService && !e.serviced) {
                        e.serviced = true; Game.addScore(Config.Earnings.Fix); Audio.sfx('score');
                        this.entities.push(new Projectile(this.player.x, playerY, e.x, e.y)); acted = true;
                    } else if (e.type === 'gas' && !e.used) {
                        e.used = true; Game.refuel(); Game.addScore(-Config.Earnings.RefuelCost); Audio.sfx('score'); acted = true;
                    } else if (e.type === 'supply' && !e.used) {
                        e.used = true; Game.addScore(Config.Earnings.Bonus); Audio.sfx('score'); acted = true;
                    }
                }
            }
        });
        if(acted) Audio.sfx('throw');
    }

    update(dt) {
        const maxSpeed = this.level === 2 ? Config.MaxSpeedLvl2 : Config.MaxSpeedLvl1;
        if(this.speed < maxSpeed) this.speed += dt * 10;
        const moveAmt = this.speed * dt;
        this.distance += moveAmt;
        Game.consumeFuel(dt * (this.level === 2 ? Config.FuelRateLvl2 : Config.FuelRateLvl1));

        if (Input.keys.ArrowLeft) this.player.x -= 300 * dt;
        if (Input.keys.ArrowRight) this.player.x += 300 * dt;
        if (Input.keys.ArrowUp) this.player.y = Math.min(300, this.player.y + 300 * dt);
        if (Input.keys.ArrowDown) this.player.y = Math.max(-50, this.player.y - 300 * dt);
        
        const roadEdge = Config.RoadWidth/2 - 20;
        if(this.player.x < -roadEdge) this.player.x = -roadEdge;
        if(this.player.x > roadEdge) this.player.x = roadEdge;

        this.hazardTimer -= dt;
        if(this.hazardTimer <= 0) {
            this.spawnHazard();
            this.hazardTimer = (Math.random() * 0.5 + 0.3) * (this.level===2 ? 0.7 : 1.0); 
        }
        
        this.envTimer -= dt;
        if(this.envTimer <= 0) {
            this.spawnEnvironment();
            this.envTimer = 0.5 + Math.random() * 0.5; 
        }

        this.entities.forEach(e => {
            if(e instanceof Projectile) e.update(dt);
            else { e.y += moveAmt; if (e.type === 'traffic') e.y += (e.speed || 200) * dt; }
        });

        this.entities = this.entities.filter(e => {
            if(e instanceof Projectile) return e.active;
            return e.y < Game.canvas.height + 200;
        });
        this.checkCollisions();
    }

    spawnHazard() {
        const startY = -200;
        const typeRoll = Math.random();
        if (typeRoll < 0.6) {
            const lane = (Math.floor(Math.random()*3)-1);
            const isSpeeder = Math.random() < 0.2;
            this.entities.push({ type: 'traffic', x: lane*(Config.RoadWidth/3), y: startY, speed: (400 + Math.random()*200) + (this.level===2?150:0) + (isSpeeder?300:0), width: 40, height: 60, speeder: isSpeeder });
        } else {
            const obsType = this.level === 2 ? (Math.random()>0.6?'oil':(Math.random()>0.5?'barrel':'trash')) : (Math.random()>0.6?'oil':(Math.random()>0.9?'rock':'cone'));
            this.entities.push({ type: 'obstacle', x: (Math.floor(Math.random()*3)-1)*(Config.RoadWidth/3), y: startY, width: 40, height: 40, kind: obsType });
        }
    }
    
    spawnEnvironment() {
        const startY = -250;
        const typeRoll = Math.random();
        const side = Math.random() > 0.5 ? 1 : -1;
        const xPos = side * 280; 
        const conflict = this.entities.some(e => (e.type==='house'||e.type==='gas'||e.type==='supply') && e.side === side && Math.abs(e.y - startY) < 350);
        if(conflict) return;

        if (typeRoll < 0.1) this.entities.push({ type: 'supply', x: xPos, y: startY, side: side, used: false });
        else if (typeRoll < 0.25) this.entities.push({ type: 'gas', x: xPos, y: startY, side: side, used: false });
        else this.entities.push({ type: 'house', x: xPos, y: startY, side: side, needsService: true, serviced: false });
    }

    checkCollisions() {
        const pRect = { 
            l: this.player.x - this.player.width/2 + 5, r: this.player.x + this.player.width/2 - 5, 
            t: Game.canvas.height - 100 - this.player.y - this.player.height/2 + 5, 
            b: Game.canvas.height - 100 - this.player.y + this.player.height/2 - 5 
        };
        this.entities.forEach(e => {
            if (e.type === 'traffic' || e.type === 'obstacle') {
                const eL = e.x - (e.width||40)/2; const eR = e.x + (e.width||40)/2;
                const eT = e.y - (e.height||40)/2; const eB = e.y + (e.height||40)/2;
                if (pRect.l < eR && pRect.r > eL && pRect.t < eB && pRect.b > eT) {
                    if(e.type === 'obstacle' && e.kind === 'oil') Audio.sfx('score');
                    else { Audio.sfx('crash'); Game.shake(0.5); this.speed = Math.max(200, this.speed * 0.5); e.y = 2000; }
                }
            }
        });
    }

    draw(ctx) {
        // Draw World (Attract Mode Logic)
        // If scene isn't active (like in menu), we might just draw a rolling road.
        // But draw() calls this.draw() so we are good.
        
        const scale = Math.min(1, ctx.canvas.width / Config.TotalViewWidth);
        const cx = ctx.canvas.width / 2;
        
        ctx.save();
        ctx.translate(cx, 0); ctx.scale(scale, scale);
        
        // Background
        ctx.fillStyle = this.level === 2 ? Config.Colors.GrassNight : Config.Colors.GrassDay;
        ctx.fillRect(-Config.TotalViewWidth/2, 0, Config.TotalViewWidth, ctx.canvas.height/scale);
        if(this.level === 2) { ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(250, 80, 40, 0, Math.PI*2); ctx.fill(); }
        
        // Road
        const roadH = ctx.canvas.height / scale; 
        ctx.fillStyle = this.level === 2 ? Config.Colors.RoadNight : Config.Colors.RoadDay;
        ctx.fillRect(-Config.RoadWidth/2, 0, Config.RoadWidth, roadH);
        
        ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 4;
        ctx.setLineDash([40, 40]); ctx.lineDashOffset = -this.distance;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, roadH); ctx.stroke(); ctx.setLineDash([]);

        // Objects
        this.entities.sort((a,b) => a.y - b.y).forEach(e => {
            ctx.save();
            if(e instanceof Projectile) { ctx.translate(e.x, e.y); e.draw(ctx); } 
            else { ctx.translate(e.x, e.y); this.drawEntity(ctx, e); }
            ctx.restore();
        });

        // Player
        ctx.save();
        const playerDrawY = roadH - 100 - this.player.y;
        ctx.translate(this.player.x, playerDrawY);
        ctx.fillStyle = '#ecf0f1'; ctx.fillRect(-20, -35, 40, 70);
        ctx.fillStyle = '#3498db'; ctx.fillRect(-20, -25, 40, 40); 
        ctx.fillStyle = 'white'; ctx.font='10px sans-serif'; ctx.textAlign='center'; ctx.fillText('TECH',0,5);
        ctx.fillStyle = '#34495e'; ctx.fillRect(-18, -32, 36, 15); 
        if(Input.keys.ArrowDown) {
            ctx.fillStyle = 'red'; ctx.shadowColor = 'red'; ctx.shadowBlur = 10;
            ctx.fillRect(-18, 30, 10, 5); ctx.fillRect(8, 30, 10, 5);
        }
        ctx.restore();
        ctx.restore(); 
    }

    drawEntity(ctx, e) {
        if(e.type === 'house') {
            ctx.fillStyle = this.level===2 ? '#4a235a' : '#ecf0f1';
            ctx.fillRect(-40, -40, 80, 60);
            ctx.fillStyle = this.level===2 ? '#2c3e50' : '#c0392b';
            ctx.beginPath(); ctx.moveTo(-50, -40); ctx.lineTo(0, -70); ctx.lineTo(50, -40); ctx.fill();
            if(e.needsService && !e.serviced) {
                ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(0, -80, 15, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'red'; ctx.fillText('!', -5, -75);
            }
        } else if (e.type === 'gas') {
            ctx.fillStyle = '#2ecc71'; ctx.fillRect(-40, -40, 80, 60); ctx.fillStyle = 'white'; ctx.fillText('GAS', -15, -10);
        } else if (e.type === 'supply') {
            ctx.fillStyle = '#d35400'; ctx.fillRect(-40, -40, 80, 60); ctx.fillStyle = 'white'; ctx.fillText('PARTS', -20, -10);
        } else if (e.type === 'traffic') {
            ctx.fillStyle = e.speeder ? '#ff0033' : (this.level===2 ? '#555' : '#e74c3c'); ctx.fillRect(-20, -30, 40, 60);
            ctx.fillStyle = e.speeder ? '#8bf' : '#f1c40f'; ctx.fillRect(-18, 25, 10, 5); ctx.fillRect(8, 25, 10, 5);
        } else if (e.type === 'obstacle') {
            if(e.kind === 'barrel') { ctx.fillStyle = '#e67e22'; ctx.fillRect(-15,-20,30,40); }
            else if (e.kind === 'oil') { ctx.fillStyle = '#111'; ctx.globalAlpha=0.8; ctx.beginPath(); ctx.ellipse(0,10,25,15,0,0,Math.PI*2); ctx.fill(); }
            else { ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.moveTo(0,-20); ctx.lineTo(15,20); ctx.lineTo(-15,20); ctx.fill(); }
        }
    }
}

class Projectile {
    constructor(startX, startY, targetX, targetY) {
        this.rawX = startX; this.rawY = startY; this.targetX = targetX; this.targetY = targetY;
        this.t = 0; this.active = true; this.rot = 0;
    }
    update(dt) {
        this.t += dt * 3; this.rot += 15 * dt; if(this.t >= 1) this.active = false;
    }
    draw(ctx) {
        const curX = this.rawX + (this.targetX - this.rawX) * this.t;
        const curY = this.rawY + (this.targetY - this.rawY) * this.t;
        ctx.save(); ctx.translate(curX, curY); ctx.rotate(this.rot);
        ctx.fillStyle = '#bdc3c7'; ctx.fillRect(-10, -3, 20, 6);
        ctx.restore();
    }
}

// --- SCENE: PLATFORMER (Level 3) ---
class PlatformerScene {
    constructor() {
        this.tech = { x: 100, y: 300, w: 30, h: 50, vx: 0, vy: 0, grounded: false, facingRight: true };
        this.camX = 0; this.platforms = []; this.enemies = []; this.projectiles = [];
        this.initLevel();
        document.getElementById('fuel-container').style.display = 'none';
        Input.checkMobile();
    }
    initLevel() {
        let x = 0;
        for(let i=0; i<20; i++) {
            let w = 300 + Math.random()*200; let gap = 50 + Math.random()*150;
            this.platforms.push({ x, y: 400 + Math.random()*100, w, h: 400 });
            if(i>2) this.enemies.push({ x: x+w/2, y: 350, w: 30, h: 30, type: 'bat', active: true, t: Math.random() });
            x += w + gap;
        }
        this.platforms.push({ x, y: 400, w: 600, h: 400 });
        this.enemies.push({ x: x+300, y: 250, w: 100, h: 150, type: 'boss', active: true, hp: 5 });
    }
    onAction() {
        Audio.sfx('throw');
        this.projectiles.push({ x: this.tech.x, y: this.tech.y + 20, vx: this.tech.facingRight ? 600 : -600, active: true });
    }
    update(dt) {
        if (Input.keys.ArrowRight) { this.tech.vx = 300; this.tech.facingRight = true; }
        else if (Input.keys.ArrowLeft) { this.tech.vx = -300; this.tech.facingRight = false; }
        else { this.tech.vx = 0; }
        if (Input.keys.ArrowUp && this.tech.grounded) { this.tech.vy = -600; this.tech.grounded = false; Audio.sfx('jump'); }
        this.tech.vy += 1500 * dt; this.tech.x += this.tech.vx * dt; this.tech.y += this.tech.vy * dt;
        
        this.tech.grounded = false;
        if(this.tech.y > Game.canvas.height + 100) Game.gameOver("FELL OFF THE ROOF!");
        
        this.platforms.forEach(p => {
            if(this.tech.x+this.tech.w > p.x && this.tech.x < p.x+p.w && this.tech.y+this.tech.h > p.y && this.tech.y+this.tech.h < p.y+p.h+30 && this.tech.vy >= 0) {
                this.tech.y = p.y - this.tech.h; this.tech.vy = 0; this.tech.grounded = true;
            }
        });
        this.camX = Math.max(0, this.tech.x - 200);

        this.projectiles.forEach(p => {
            p.x += p.vx * dt;
            this.enemies.forEach(e => {
                if(e.active && p.active && p.x > e.x && p.x < e.x+e.w && p.y > e.y && p.y < e.y+e.h) {
                    p.active = false; Audio.sfx('crash');
                    if(e.type === 'boss') { e.hp--; if(e.hp<=0) { e.active = false; Game.win(); } } else { e.active = false; Game.addScore(100); }
                }
            });
        });
        
        this.enemies.forEach(e => {
            if(e.active) {
                if(e.type === 'bat') { e.x -= 100 * dt; e.y += Math.sin(Date.now()/200)*2; }
                if(this.tech.x < e.x+e.w && this.tech.x+this.tech.w > e.x && this.tech.y < e.y+e.h && this.tech.y+this.tech.h > e.y) Game.gameOver("HIT BY ENEMY!");
            }
        });
    }
    draw(ctx) {
        const grad = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
        grad.addColorStop(0, '#0f0c29'); grad.addColorStop(1, '#302b63');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.save(); ctx.translate(-this.camX, 0);
        ctx.fillStyle = '#555';
        this.platforms.forEach(p => { ctx.fillRect(p.x, p.y, p.w, p.h); ctx.fillStyle = '#444'; ctx.fillRect(p.x, p.y, p.w, 10); ctx.fillStyle = '#555'; });
        this.enemies.forEach(e => {
            if(e.active) {
                if(e.type === 'bat') { ctx.fillStyle = '#3498db'; ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(e.x+e.w/2, e.y+e.h); ctx.lineTo(e.x+e.w, e.y); ctx.fill(); }
                else { ctx.fillStyle = '#2c3e50'; ctx.fillRect(e.x, e.y, e.w, e.h); }
            }
        });
        ctx.fillStyle = '#ecf0f1'; ctx.fillRect(this.tech.x, this.tech.y, this.tech.w, this.tech.h);
        ctx.fillStyle = '#bdc3c7'; this.projectiles.forEach(p => { if(p.active) ctx.fillRect(p.x, p.y, 20, 5); });
        ctx.restore();
    }
}

// --- GAME ENGINE ---
const Game = {
    canvas: null, ctx: null, lastTime: 0, scene: null, score: 0, fuel: 100, shiftTime: 0, level: 1, shakeTimer: 0,
    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        initFirebase();
        Input.init();
        document.getElementById('btn-music').onclick = () => Audio.toggleMute();
        document.getElementById('btn-menu').onclick = () => this.showMenu();
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.showMenu();
        // Start background driving scene for menu "Attract Mode"
        this.scene = new DrivingScene(1); 
        this.loop(0);
    },
    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; },
    start() {
        this.score = 0; this.fuel = 100; this.shiftTime = 0; this.level = 1;
        this.loadLevel(1); Audio.startMusic(107); this.hideScreens();
    },
    loadLevel(lvl) {
        this.level = lvl;
        const screen = document.getElementById('screen-level');
        if(lvl === 1) { this.scene = new DrivingScene(1); }
        else if (lvl === 2) {
            document.getElementById('level-title').innerText = "LEVEL 2";
            screen.classList.remove('hidden'); Audio.sfx('levelup');
            setTimeout(() => screen.classList.add('hidden'), 3000);
            this.scene = new DrivingScene(2); Audio.startMusic(90);
        } else if (lvl === 3) {
            document.getElementById('level-title').innerText = "LEVEL 3";
            screen.classList.remove('hidden'); Audio.sfx('levelup');
            setTimeout(() => screen.classList.add('hidden'), 3000);
            this.scene = new PlatformerScene(); Audio.startMusic(80);
        }
    },
    update(dt) {
        if(this.shakeTimer > 0) this.shakeTimer -= dt;
        // In menu (when start screen is visible), just update driving without player input
        const isMenu = !document.getElementById('screen-start').classList.contains('hidden');
        if(isMenu) {
             if(this.scene && this.scene.update) {
                 // Hack to animate background without player moving or dying
                 const oldFuel = this.fuel;
                 this.scene.speed = 200; 
                 this.scene.update(dt);
                 this.fuel = oldFuel; // Infinite fuel in menu
                 this.scene.player.x = 0; // Center van
             }
             return;
        }

        if(!this.scene) return;
        this.shiftTime += dt;
        this.scene.update(dt);
        if(this.level === 1 && this.score >= 1000) this.loadLevel(2);
        if(this.level === 2 && this.score >= 2000) this.loadLevel(3);
        this.updateHUD();
    },
    draw() {
        if(!this.scene) return;
        this.ctx.save();
        if(this.shakeTimer > 0) {
            const dx = (Math.random()-0.5)*10*this.shakeTimer;
            const dy = (Math.random()-0.5)*10*this.shakeTimer;
            this.ctx.translate(dx, dy);
        }
        this.scene.draw(this.ctx);
        this.ctx.restore();
        this.ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
        for (let i = 0; i < this.canvas.height; i += 4) this.ctx.fillRect(0, i, this.canvas.width, 2);
    },
    loop(timestamp) {
        if(!this.lastTime) this.lastTime = timestamp;
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        this.update(dt); this.draw();
        requestAnimationFrame((t) => this.loop(t));
    },
    addScore(amount) { this.score += amount; },
    consumeFuel(amount) { this.fuel -= amount; if(this.fuel <= 0) this.gameOver("OUT OF GAS!"); },
    refuel() { this.fuel = 100; },
    shake(amount) { this.shakeTimer = amount; },
    updateHUD() {
        document.getElementById('hud-score').innerText = `CASH: $${this.score}`;
        const m = Math.floor(this.shiftTime / 60); const s = Math.floor(this.shiftTime % 60);
        document.getElementById('hud-time').innerText = `SHIFT: ${m}:${s<10?'0':''}${s}`;
        const fill = document.getElementById('fuel-fill');
        fill.style.width = `${Math.max(0, this.fuel)}%`;
    },
    gameOver(reason) {
        // Stop scene
        this.scene = null; 
        Audio.stopMusic(); Audio.sfx('crash');
        document.getElementById('end-reason').innerText = reason;
        document.getElementById('end-score').innerText = `EARNINGS: $${this.score}`;
        const high = localStorage.getItem('hvac_high_score') || 0;
        document.getElementById('local-high-score').innerText = Math.max(high, this.score);
        document.getElementById('screen-gameover').classList.remove('hidden');
    },
    win() {
        this.scene = null; Audio.stopMusic();
        document.getElementById('win-score').innerText = `$${this.score}`;
        document.getElementById('screen-win').classList.remove('hidden');
    },
    showMenu() {
        Audio.stopMusic(); this.hideScreens();
        document.getElementById('screen-start').classList.remove('hidden');
        this.scene = new DrivingScene(1); // Restart attract mode
    },
    hideScreens() { document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden')); }
};

window.onload = () => Game.init();

// Global Bindings
window.Game = Game;
window.submitScore = () => { const name = document.getElementById('username').value; if(name) { saveScore(name, Game.score); Game.showMenu(); } };
window.submitWinScore = () => { const name = document.getElementById('win-username').value; if(name) { saveScore(name, Game.score); Game.showMenu(); } };
window.toggleMusic = () => Audio.toggleMute();
window.quitGame = () => Game.showMenu();
window.resetGame = () => Game.start();
window.startGame = () => Game.start();
window.loginGoogle = () => window.loginGoogle();

</script>
</body>
</html>
