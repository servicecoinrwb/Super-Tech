<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Tech: Service Run</title>
    <link rel="icon" href="https://imageview.mechanicaltemp.com/objects/uploads/d4641033-922a-45e1-bd01-2d5c74b8ecd2">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #222;
            --text-color: #fff;
            --primary-color: #3498db;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --warning-color: #f1c40f;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 100%;
        }

        /* --- UI OVERLAYS --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            text-shadow: 2px 2px 0 #000;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            pointer-events: auto;
        }

        .hud-stats { display: flex; flex-direction: column; gap: 8px; font-size: 14px; }
        .hud-controls { display: flex; gap: 10px; }

        /* Fuel Bar */
        #fuel-container { width: 150px; }
        .fuel-label { font-size: 10px; color: #ccc; margin-bottom: 3px; }
        .fuel-track { width: 100%; height: 12px; border: 2px solid white; background: #333; }
        .fuel-fill { width: 100%; height: 100%; background-color: var(--success-color); transition: width 0.1s; }
        .fuel-fill.low { background-color: var(--danger-color); animation: blink 0.5s infinite; }

        /* Screens */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            text-align: center;
            z-index: 50;
            transition: opacity 0.3s;
        }
        .hidden { display: none !important; opacity: 0; pointer-events: none; }

        h1 { font-size: 32px; color: var(--warning-color); text-shadow: 4px 4px 0 #8B4500; margin-bottom: 20px; line-height: 1.4; }
        p { font-size: 14px; line-height: 24px; color: #ccc; max-width: 600px; margin: 0 auto 20px; padding: 0 20px; }
        
        .logo-img {
            max-width: 250px; width: 80%; height: auto; margin-bottom: 20px;
            image-rendering: pixelated; filter: contrast(1.2) brightness(1.1);
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.2));
        }

        /* Buttons */
        .btn-retro {
            background: var(--danger-color);
            border: 4px solid #c0392b;
            color: white;
            font-family: inherit;
            font-size: 16px;
            padding: 15px 30px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 6px 0 #962d22;
            margin-top: 15px;
        }
        .btn-retro:active { transform: translateY(6px); box-shadow: 0 0 0 #962d22; }
        .btn-secondary { background: #7f8c8d; border-color: #555; box-shadow: 0 6px 0 #333; }
        
        .btn-icon {
            background: rgba(255,255,255,0.1);
            border: 2px solid white;
            color: white;
            font-family: inherit;
            width: 40px; height: 40px;
            cursor: pointer;
            font-size: 16px;
            display: flex; align-items: center; justify-content: center;
        }
        .btn-icon:hover { background: rgba(255,255,255,0.3); }

        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Enabled via JS based on screen size */
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 40; pointer-events: none;
        }
        .touch-zone {
            pointer-events: auto;
            position: absolute; bottom: 30px;
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: white;
            backdrop-filter: blur(4px);
            user-select: none;
        }
        .touch-zone:active { background: rgba(255, 255, 255, 0.3); transform: scale(0.95); }
        
        #dpad-left { left: 20px; }
        #dpad-right { left: 110px; }
        #dpad-up { left: 65px; bottom: 90px; display: none; } /* Only for platformer/drive up */
        #dpad-down { left: 65px; bottom: 20px; display: none; } /* Only for drive */
        
        #btn-action { 
            right: 30px; width: 90px; height: 90px; 
            border-color: var(--danger-color); color: var(--danger-color);
            background: rgba(231, 76, 60, 0.15);
            font-size: 14px; font-weight: bold;
        }

        /* Animations */
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="ui-layer">
        <div class="hud-panel">
            <div class="hud-stats">
                <div id="hud-score">CASH: $0</div>
                <div id="hud-time" style="color: var(--warning-color);">SHIFT: 00:00</div>
                <div id="fuel-container">
                    <div class="fuel-label">FUEL</div>
                    <div class="fuel-track"><div id="fuel-fill" class="fuel-fill"></div></div>
                </div>
            </div>
            <div class="hud-controls">
                <button class="btn-icon" id="btn-music">♫</button>
                <button class="btn-icon" id="btn-menu">☰</button>
            </div>
        </div>
        
        <!-- Mobile Controls Overlay -->
        <div id="mobile-controls">
            <div id="dpad-left" class="touch-zone">◄</div>
            <div id="dpad-right" class="touch-zone">►</div>
            <div id="dpad-up" class="touch-zone">▲</div>
            <div id="dpad-down" class="touch-zone">▼</div>
            <div id="btn-action" class="touch-zone">ACT</div>
        </div>
    </div>

    <!-- SCREENS -->
    <div id="screen-start" class="screen">
        <img src="https://imageview.mechanicaltemp.com/objects/uploads/b06a602d-a276-47bc-808e-585ada089aa4" alt="Mechanical Temp" class="logo-img">
        <h1>SUPER TECH</h1>
        <p>Drive the van, fix the HVACs, survive the shift.</p>
        <p style="font-size: 10px; color: #888;">ARROWS to Move • SPACE to Action</p>
        <button class="btn-retro" onclick="Game.start()">START ENGINE</button>
    </div>

    <div id="screen-level" class="screen hidden">
        <h1 id="level-title" style="color: var(--danger-color);">LEVEL 2</h1>
        <h1 id="level-subtitle" style="font-size: 40px; margin-top: -10px;">ON CALL</h1>
        <p id="level-desc">NIGHT SHIFT BEGINS</p>
    </div>

    <div id="screen-gameover" class="screen hidden">
        <h1>GAME OVER</h1>
        <p id="end-reason" style="color: var(--danger-color);">CRASHED!</p>
        <p id="end-score">EARNINGS: $0</p>
        <button class="btn-retro" onclick="Game.start()">NEXT SHIFT</button>
        <button class="btn-retro btn-secondary" onclick="Game.showMenu()">MENU</button>
    </div>
    
    <div id="screen-win" class="screen hidden" style="background: rgba(39, 174, 96, 0.95);">
        <h1>MISSION COMPLETE</h1>
        <p>You reached the Master Chiller!</p>
        <p id="win-score" style="font-size: 24px; color: gold;">$0</p>
        <button class="btn-retro" onclick="Game.showMenu()">RETURN TO HQ</button>
    </div>
</div>

<script>
/**
 * SUPER TECH - Refactored Scalable Engine
 */

// --- CONFIGURATION ---
const Config = {
    RoadWidth: 400,
    TotalViewWidth: 700, // Includes side scenery
    BaseSpeed: 300,
    MaxSpeedLvl1: 800,
    MaxSpeedLvl2: 1000,
    FuelRateLvl1: 5,
    FuelRateLvl2: 7,
    Earnings: {
        Fix: 50,
        RefuelCost: 100,
        Bonus: 250,
        EnemyKill: 100
    },
    Colors: {
        GrassDay: '#2c3e50',
        GrassNight: '#1a0b2e',
        RoadDay: '#7f8c8d',
        RoadNight: '#34495e'
    }
};

// --- SYSTEM: INPUT ---
const Input = {
    keys: { ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false, Space: false },
    
    init() {
        window.addEventListener('keydown', e => this.handleKey(e.code, true));
        window.addEventListener('keyup', e => this.handleKey(e.code, false));
        
        // Touch Bindings
        this.bindTouch('dpad-left', 'ArrowLeft');
        this.bindTouch('dpad-right', 'ArrowRight');
        this.bindTouch('dpad-up', 'ArrowUp');
        this.bindTouch('dpad-down', 'ArrowDown');
        this.bindTouch('btn-action', 'Space');

        // Responsive visibility
        this.checkMobile();
        window.addEventListener('resize', () => this.checkMobile());
    },

    handleKey(code, isDown) {
        if (this.keys.hasOwnProperty(code)) {
            // Prevent spamming action
            if(code === 'Space' && isDown && this.keys.Space) return;
            this.keys[code] = isDown;
            if(code === 'Space' && isDown && Game.scene) Game.scene.onAction();
        }
    },

    bindTouch(id, code) {
        const el = document.getElementById(id);
        if(!el) return;
        el.addEventListener('touchstart', (e) => { e.preventDefault(); this.handleKey(code, true); });
        el.addEventListener('touchend', (e) => { e.preventDefault(); this.handleKey(code, false); });
    },

    checkMobile() {
        const isMobile = window.innerWidth < 900 || ('ontouchstart' in window);
        document.getElementById('mobile-controls').style.display = isMobile ? 'block' : 'none';
        
        // Toggle D-Pad buttons visibility handled by scenes, but default check here
        // We'll let scenes toggle specific buttons if needed
    }
};

// --- SYSTEM: AUDIO ---
const Audio = {
    ctx: null,
    muted: false,
    timer: null,
    beat: 0,
    tempo: 107,

    init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    },

    toggleMute() {
        this.muted = !this.muted;
        if(this.muted) this.stopMusic();
        else this.startMusic();
    },

    startMusic(bpm = 107) {
        if(this.muted) return;
        this.init();
        if(this.ctx.state === 'suspended') this.ctx.resume();
        this.stopMusic();
        this.beat = 0;
        this.tempo = bpm;
        this.timer = setInterval(() => this.playBeat(), this.tempo);
    },

    stopMusic() {
        if(this.timer) clearInterval(this.timer);
    },

    playBeat() {
        if(!this.ctx || this.muted) return;
        const t = this.ctx.currentTime;
        
        // Bass Line (Sawtooth)
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'sawtooth';
        
        // Simple Rock Progression
        const notes = [82.41, 82.41, 82.41, 82.41, 98.00, 82.41, 110.00, 98.00]; // E, G, A pattern
        let freq = notes[this.beat % 8];
        
        // Pitch shift for intensity levels
        if(Game.level >= 2) freq *= 1.122; 
        if(Game.level === 3) freq *= 1.122;

        osc.frequency.setValueAtTime(freq, t);
        gain.gain.setValueAtTime(0.15, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        osc.start(t); osc.stop(t + 0.1);

        // Kick Drum
        if (this.beat % 4 === 0) {
            const kOsc = this.ctx.createOscillator();
            const kGain = this.ctx.createGain();
            kOsc.connect(kGain); kGain.connect(this.ctx.destination);
            kOsc.frequency.setValueAtTime(150, t);
            kOsc.frequency.exponentialRampToValueAtTime(0.01, t + 0.1);
            kGain.gain.setValueAtTime(0.4, t);
            kGain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
            kOsc.start(t); kOsc.stop(t + 0.1);
        }
        
        this.beat++;
    },

    sfx(type) {
        if(!this.ctx || this.muted) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);

        if (type === 'jump' || type === 'throw') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(200, t);
            osc.frequency.linearRampToValueAtTime(400, t + 0.1);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.1);
            osc.start(t); osc.stop(t + 0.1);
        } else if (type === 'crash') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, t);
            osc.frequency.exponentialRampToValueAtTime(10, t + 0.3);
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
            osc.start(t); osc.stop(t + 0.3);
        } else if (type === 'score') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, t);
            osc.frequency.setValueAtTime(1200, t + 0.1);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.3);
            osc.start(t); osc.stop(t + 0.3);
        } else if (type === 'levelup') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(440, t);
            osc.frequency.setValueAtTime(880, t + 0.5);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.linearRampToValueAtTime(0.0, t + 1.0);
            osc.start(t); osc.stop(t + 1.0);
        }
    }
};

// --- SCENE: DRIVING (Levels 1 & 2) ---

class DrivingScene {
    constructor(level) {
        this.level = level;
        this.player = { x: 0, y: 0, width: 40, height: 70 };
        this.entities = [];
        this.speed = Config.BaseSpeed;
        this.distance = 0; // Needed for animating road lines
        this.hazardTimer = 0;
        this.envTimer = 0;
        
        // Setup UI for Driving
        document.getElementById('fuel-container').style.display = 'block';
        document.getElementById('dpad-up').style.display = 'flex';
        document.getElementById('dpad-down').style.display = 'flex';
    }

    onAction() {
        const playerY = Game.canvas.height - 100 - this.player.y;
        let acted = false;

        this.entities.forEach(e => {
            if (Math.abs(e.y - playerY) < 120) {
                const aligned = (e.side === -1 && this.player.x < -50) || (e.side === 1 && this.player.x > 50);
                if (aligned) {
                    if (e.type === 'house' && e.needsService && !e.serviced) {
                        e.serviced = true;
                        Game.addScore(Config.Earnings.Fix);
                        Audio.sfx('score');
                        this.entities.push(new Projectile(this.player.x, playerY, e.x, e.y));
                        acted = true;
                    } else if (e.type === 'gas' && !e.used) {
                        e.used = true;
                        Game.refuel();
                        Game.addScore(-Config.Earnings.RefuelCost);
                        Audio.sfx('score');
                        acted = true;
                    } else if (e.type === 'supply' && !e.used) {
                        e.used = true;
                        Game.addScore(Config.Earnings.Bonus);
                        Audio.sfx('score');
                        acted = true;
                    }
                }
            }
        });

        if(acted) Audio.sfx('throw');
    }

    update(dt) {
        // Speed & Fuel
        const maxSpeed = this.level === 2 ? Config.MaxSpeedLvl2 : Config.MaxSpeedLvl1;
        if(this.speed < maxSpeed) this.speed += dt * 10;
        
        const moveAmt = this.speed * dt;
        this.distance += moveAmt; // Animate lines
        
        Game.consumeFuel(dt * (this.level === 2 ? Config.FuelRateLvl2 : Config.FuelRateLvl1));

        // Player Movement
        if (Input.keys.ArrowLeft) this.player.x -= 300 * dt;
        if (Input.keys.ArrowRight) this.player.x += 300 * dt;
        if (Input.keys.ArrowUp) this.player.y = Math.min(300, this.player.y + 300 * dt);
        if (Input.keys.ArrowDown) this.player.y = Math.max(-50, this.player.y - 300 * dt);
        
        const roadEdge = Config.RoadWidth/2 - 20;
        if(this.player.x < -roadEdge) this.player.x = -roadEdge;
        if(this.player.x > roadEdge) this.player.x = roadEdge;

        // Independent Spawning Logic
        this.hazardTimer -= dt;
        if(this.hazardTimer <= 0) {
            this.spawnHazard();
            // Faster spawns in level 2
            this.hazardTimer = (Math.random() * 0.5 + 0.3) * (this.level===2 ? 0.7 : 1.0); 
        }
        
        this.envTimer -= dt;
        if(this.envTimer <= 0) {
            this.spawnEnvironment();
            // Regular cadence for buildings
            this.envTimer = 0.5 + Math.random() * 0.5; 
        }

        // Entities Update (Move Down)
        this.entities.forEach(e => {
            if(e instanceof Projectile) {
                e.update(dt);
            } else {
                e.y += moveAmt; 
                if (e.type === 'traffic') e.y += (e.speed || 200) * dt; 
            }
        });

        // Cleanup
        this.entities = this.entities.filter(e => {
            if(e instanceof Projectile) return e.active;
            return e.y < Game.canvas.height + 200;
        });

        this.checkCollisions();
    }

    spawnHazard() {
        const startY = -200;
        const typeRoll = Math.random();
        
        if (typeRoll < 0.6) { // Traffic
            const lane = (Math.floor(Math.random()*3)-1);
            const isSpeeder = Math.random() < 0.2;
            this.entities.push({ 
                type: 'traffic', x: lane*(Config.RoadWidth/3), y: startY, 
                speed: (400 + Math.random()*200) + (this.level===2?150:0) + (isSpeeder?300:0), 
                width: 40, height: 60, speeder: isSpeeder
            });
        } else { // Obstacle
            const obsType = this.level === 2 ? (Math.random()>0.6?'oil':(Math.random()>0.5?'barrel':'trash')) : (Math.random()>0.6?'oil':(Math.random()>0.9?'rock':'cone'));
            this.entities.push({ type: 'obstacle', x: (Math.floor(Math.random()*3)-1)*(Config.RoadWidth/3), y: startY, width: 40, height: 40, kind: obsType });
        }
    }
    
    spawnEnvironment() {
        const startY = -250;
        const typeRoll = Math.random();
        const side = Math.random() > 0.5 ? 1 : -1;
        const xPos = side * 280; // Distance from center
        
        // Ensure no overlap with recent buildings on same side
        const conflict = this.entities.some(e => (e.type==='house'||e.type==='gas'||e.type==='supply') && e.side === side && e.y < 200);
        if(conflict) return;

        if (typeRoll < 0.1) this.entities.push({ type: 'supply', x: xPos, y: startY, side: side, used: false });
        else if (typeRoll < 0.25) this.entities.push({ type: 'gas', x: xPos, y: startY, side: side, used: false });
        else this.entities.push({ type: 'house', x: xPos, y: startY, side: side, needsService: true, serviced: false });
    }

    checkCollisions() {
        const pRect = { 
            l: this.player.x - this.player.width/2 + 5, 
            r: this.player.x + this.player.width/2 - 5, 
            t: Game.canvas.height - 100 - this.player.y - this.player.height/2 + 5, 
            b: Game.canvas.height - 100 - this.player.y + this.player.height/2 - 5 
        };

        this.entities.forEach(e => {
            if (e.type === 'traffic' || e.type === 'obstacle') {
                const eL = e.x - (e.width||40)/2;
                const eR = e.x + (e.width||40)/2;
                const eT = e.y - (e.height||40)/2;
                const eB = e.y + (e.height||40)/2;

                if (pRect.l < eR && pRect.r > eL && pRect.t < eB && pRect.b > eT) {
                    if(e.type === 'obstacle' && e.kind === 'oil') {
                        Audio.sfx('score'); // Slipping sound placeholder
                        // Oil logic could go here (slide effect)
                    } else {
                        Audio.sfx('crash');
                        Game.shake(0.5);
                        this.speed = Math.max(200, this.speed * 0.5);
                        e.y = 2000; // Remove logic
                    }
                }
            }
        });
    }

    draw(ctx) {
        // Auto Scale for Narrow Screens (Fixes Missing Buildings)
        const scale = Math.min(1, ctx.canvas.width / Config.TotalViewWidth);
        
        ctx.save();
        ctx.translate(ctx.canvas.width/2, 0); // Center canvas
        ctx.scale(scale, scale); // Scale entire scene
        ctx.translate(-ctx.canvas.width/2, 0); // Undo center offset for logic but keep zoom center
        
        // Correct centering with scale applied
        // Effectively we want to draw as if canvas is 700px wide, centered
        const virtualCX = ctx.canvas.width / 2;

        // Background
        ctx.fillStyle = this.level === 2 ? Config.Colors.GrassNight : Config.Colors.GrassDay;
        // Fill wider than canvas to cover scaling gaps
        ctx.fillRect(-virtualCX*2, 0, virtualCX*4, ctx.canvas.height / scale); 
        
        // Level 2 Moon
        if(this.level === 2) {
            ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(virtualCX + 300, 80, 40, 0, Math.PI*2); ctx.fill();
        }
        
        // Road
        ctx.fillStyle = this.level === 2 ? Config.Colors.RoadNight : Config.Colors.RoadDay;
        ctx.fillRect(virtualCX - Config.RoadWidth/2, 0, Config.RoadWidth, ctx.canvas.height / scale);
        
        // Lines
        ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 4;
        ctx.setLineDash([40, 40]); ctx.lineDashOffset = -this.distance;
        ctx.beginPath(); ctx.moveTo(virtualCX, 0); ctx.lineTo(virtualCX, ctx.canvas.height / scale); ctx.stroke();
        ctx.setLineDash([]);

        this.entities.sort((a,b) => a.y - b.y).forEach(e => {
            ctx.save();
            if(e instanceof Projectile) ctx.translate(virtualCX + e.x, Game.canvas.height - 100 - (e.y - this.player.y)); 
            else ctx.translate(virtualCX + e.x, e.y);
            
            if(e instanceof Projectile) {
                 ctx.restore();
                 // Re-apply scale for projectile
                 ctx.save();
                 ctx.translate(ctx.canvas.width/2, 0);
                 ctx.scale(scale, scale);
                 ctx.translate(-ctx.canvas.width/2, 0);
                 e.draw(ctx, 0); 
                 ctx.restore();
                 return;
            }

            this.drawEntity(ctx, e);
            ctx.restore();
        });

        // Player
        ctx.save();
        const drawY = Game.canvas.height - 100 - this.player.y;
        ctx.translate(virtualCX + this.player.x, drawY);
        ctx.fillStyle = '#ecf0f1'; ctx.fillRect(-20, -35, 40, 70);
        ctx.fillStyle = '#3498db'; ctx.fillRect(-20, -25, 40, 40); 
        ctx.fillStyle = 'white'; ctx.font='10px sans-serif'; ctx.textAlign='center'; ctx.fillText('TECH',0,5);
        ctx.fillStyle = '#34495e'; ctx.fillRect(-18, -32, 36, 15); 
        if(Input.keys.ArrowDown) {
            ctx.fillStyle = 'red'; ctx.shadowColor = 'red'; ctx.shadowBlur = 10;
            ctx.fillRect(-18, 30, 10, 5); ctx.fillRect(8, 30, 10, 5);
            ctx.shadowBlur = 0;
        }
        ctx.restore();
        
        ctx.restore(); // End scale
    }

    drawEntity(ctx, e) {
        if(e.type === 'house') {
            ctx.fillStyle = this.level===2 ? '#4a235a' : '#ecf0f1';
            ctx.fillRect(-40, -40, 80, 60);
            ctx.fillStyle = this.level===2 ? '#2c3e50' : '#c0392b';
            ctx.beginPath(); ctx.moveTo(-50, -40); ctx.lineTo(0, -70); ctx.lineTo(50, -40); ctx.fill();
            if(e.needsService && !e.serviced) {
                ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(0, -80, 15, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'red'; ctx.fillText('!', -5, -75);
            }
        } else if (e.type === 'gas') {
            ctx.fillStyle = '#2ecc71'; ctx.fillRect(-40, -40, 80, 60);
            ctx.fillStyle = 'white'; ctx.font = '10px sans-serif'; ctx.fillText('GAS', -15, -10);
        } else if (e.type === 'supply') {
            ctx.fillStyle = '#d35400'; ctx.fillRect(-40, -40, 80, 60);
            ctx.fillStyle = 'white'; ctx.font = '10px sans-serif'; ctx.fillText('PARTS', -20, -10);
        } else if (e.type === 'traffic') {
            ctx.fillStyle = e.speeder ? '#ff0033' : (this.level===2 ? '#555' : '#e74c3c');
            ctx.fillRect(-20, -30, 40, 60);
            ctx.fillStyle = e.speeder ? '#8bf' : '#f1c40f';
            if(this.level===2) { 
               ctx.fillStyle='#fff'; ctx.globalAlpha=0.3; 
               ctx.beginPath(); ctx.moveTo(-15,30); ctx.lineTo(-30,100); ctx.lineTo(30,100); ctx.lineTo(15,30); ctx.fill(); ctx.globalAlpha=1; 
            }
            ctx.fillRect(-18, 25, 10, 5); ctx.fillRect(8, 25, 10, 5);
        } else if (e.type === 'obstacle') {
            if(e.kind === 'barrel') {
                ctx.fillStyle = '#e67e22'; ctx.fillRect(-15,-20,30,40);
                ctx.fillStyle = '#fff'; ctx.fillRect(-15,-10,30,10); ctx.fillRect(-15,10,30,10);
            } else if (e.kind === 'trash') {
                ctx.fillStyle = '#95a5a6'; ctx.fillRect(-12,-18,24,36);
            } else if (e.kind === 'oil') {
                ctx.fillStyle = '#111'; ctx.globalAlpha=0.8; ctx.beginPath(); ctx.ellipse(0,10,25,15,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
            } else {
                ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.moveTo(0,-20); ctx.lineTo(15,20); ctx.lineTo(-15,20); ctx.fill();
            }
        }
    }
}

class Projectile {
    constructor(startX, startY, targetX, targetY) {
        this.rawX = startX; 
        this.rawY = startY;
        this.targetX = targetX;
        this.targetY = targetY;
        this.t = 0;
        this.active = true;
        this.rot = 0;
    }
    update(dt) {
        this.t += dt * 3;
        this.rot += 15 * dt;
        if(this.t >= 1) this.active = false;
    }
    draw(ctx) {
        // Lerp position
        const cx = ctx.canvas.width / 2;
        const curX = this.rawX + (this.targetX - this.rawX) * this.t;
        const curY = this.rawY + (this.targetY - this.rawY) * this.t;
        
        ctx.save();
        ctx.translate(cx + curX, curY);
        ctx.rotate(this.rot);
        ctx.fillStyle = '#bdc3c7'; ctx.fillRect(-10, -3, 20, 6);
        ctx.beginPath(); ctx.arc(-10, 0, 6, 0, Math.PI * 2); ctx.arc(10, 0, 6, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }
}

// --- SCENE: PLATFORMER (Level 3) ---

class PlatformerScene {
    constructor() {
        this.tech = { x: 100, y: 300, w: 30, h: 50, vx: 0, vy: 0, grounded: false, facingRight: true };
        this.camX = 0;
        this.platforms = [];
        this.enemies = [];
        this.projectiles = [];
        this.initLevel();
        
        // UI Setup
        document.getElementById('fuel-container').style.display = 'none';
        document.getElementById('dpad-up').style.display = 'flex';
        document.getElementById('dpad-down').style.display = 'none';
    }

    initLevel() {
        let x = 0;
        for(let i=0; i<20; i++) {
            let w = 300 + Math.random()*200;
            let gap = 50 + Math.random()*150;
            this.platforms.push({ x, y: 400 + Math.random()*100, w, h: 400 });
            if(i>2) this.enemies.push({ x: x+w/2, y: 350, w: 30, h: 30, type: 'bat', active: true, t: Math.random() });
            x += w + gap;
        }
        this.platforms.push({ x, y: 400, w: 600, h: 400 });
        this.enemies.push({ x: x+300, y: 250, w: 100, h: 150, type: 'boss', active: true, hp: 5 });
    }

    onAction() {
        Audio.sfx('throw');
        this.projectiles.push({
            x: this.tech.x, y: this.tech.y + 20, vx: this.tech.facingRight ? 600 : -600, active: true
        });
    }

    update(dt) {
        // Movement
        if (Input.keys.ArrowRight) { this.tech.vx = 300; this.tech.facingRight = true; }
        else if (Input.keys.ArrowLeft) { this.tech.vx = -300; this.tech.facingRight = false; }
        else { this.tech.vx = 0; }

        if (Input.keys.ArrowUp && this.tech.grounded) {
            this.tech.vy = -600; this.tech.grounded = false; Audio.sfx('jump');
        }

        this.tech.vy += 1500 * dt;
        this.tech.x += this.tech.vx * dt;
        this.tech.y += this.tech.vy * dt;

        this.tech.grounded = false;
        if(this.tech.y > Game.canvas.height + 100) Game.gameOver("FELL OFF THE ROOF!");

        this.platforms.forEach(p => {
            if(this.tech.x+this.tech.w > p.x && this.tech.x < p.x+p.w &&
               this.tech.y+this.tech.h > p.y && this.tech.y+this.tech.h < p.y+p.h+30 && this.tech.vy >= 0) {
                this.tech.y = p.y - this.tech.h;
                this.tech.vy = 0;
                this.tech.grounded = true;
            }
        });

        this.camX = Math.max(0, this.tech.x - 200);

        // Projectiles
        this.projectiles.forEach(p => {
            p.x += p.vx * dt;
            this.enemies.forEach(e => {
                if(e.active && p.active && p.x > e.x && p.x < e.x+e.w && p.y > e.y && p.y < e.y+e.h) {
                    p.active = false;
                    Audio.sfx('crash');
                    if(e.type === 'boss') {
                        e.hp--;
                        if(e.hp<=0) { e.active = false; Game.win(); }
                    } else {
                        e.active = false;
                        Game.addScore(100);
                    }
                }
            });
        });
        
        this.enemies.forEach(e => {
            if(!e.active) return;
            if(e.type === 'bat') { e.x -= 100 * dt; e.y += Math.sin(Date.now()/200)*2; }
            if(this.tech.x < e.x+e.w && this.tech.x+this.tech.w > e.x &&
               this.tech.y < e.y+e.h && this.tech.y+this.tech.h > e.y) {
                Game.gameOver("HIT BY ENEMY!");
            }
        });
    }

    draw(ctx) {
        const grad = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
        grad.addColorStop(0, '#0f0c29'); grad.addColorStop(1, '#302b63');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        ctx.save();
        ctx.translate(-this.camX, 0);

        ctx.fillStyle = '#555';
        this.platforms.forEach(p => {
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.fillStyle = '#444'; ctx.fillRect(p.x, p.y, p.w, 10); ctx.fillStyle = '#555';
        });

        this.enemies.forEach(e => {
            if(!e.active) return;
            if(e.type === 'bat') {
                ctx.fillStyle = '#3498db';
                ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(e.x+e.w/2, e.y+e.h); ctx.lineTo(e.x+e.w, e.y); ctx.fill();
            } else if (e.type === 'boss') {
                ctx.fillStyle = '#2c3e50'; ctx.fillRect(e.x, e.y, e.w, e.h);
                ctx.fillStyle = '#e74c3c'; ctx.fillRect(e.x+10, e.y+10, e.w-20, 20);
            }
        });

        ctx.fillStyle = '#ecf0f1'; ctx.fillRect(this.tech.x, this.tech.y, this.tech.w, this.tech.h);
        ctx.fillStyle = '#3498db'; ctx.fillRect(this.tech.x, this.tech.y, this.tech.w, 10);

        ctx.fillStyle = '#bdc3c7';
        this.projectiles.forEach(p => { if(p.active) ctx.fillRect(p.x, p.y, 20, 5); });

        ctx.restore();
    }
}

// --- GAME ENGINE ---

const Game = {
    canvas: null,
    ctx: null,
    lastTime: 0,
    scene: null,
    score: 0,
    fuel: 100,
    shiftTime: 0,
    level: 1,
    shake: 0,

    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        Input.init();
        
        document.getElementById('btn-music').onclick = () => Audio.toggleMute();
        document.getElementById('btn-menu').onclick = () => this.showMenu();
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.showMenu();
        this.loop(0);
    },

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    },

    start() {
        this.score = 0;
        this.fuel = 100;
        this.shiftTime = 0;
        this.level = 1;
        this.loadLevel(1);
        Audio.startMusic(107);
        this.hideScreens();
    },

    loadLevel(lvl) {
        this.level = lvl;
        
        const screen = document.getElementById('screen-level');
        const title = document.getElementById('level-title');
        const sub = document.getElementById('level-subtitle');
        
        if(lvl === 1) {
            this.scene = new DrivingScene(1);
        } else if (lvl === 2) {
            title.innerText = "LEVEL 2"; sub.innerText = "ON CALL";
            screen.classList.remove('hidden');
            Audio.sfx('levelup');
            setTimeout(() => screen.classList.add('hidden'), 3000);
            this.scene = new DrivingScene(2);
            Audio.startMusic(90);
        } else if (lvl === 3) {
            title.innerText = "LEVEL 3"; sub.innerText = "ROOFTOP RUMBLE";
            screen.classList.remove('hidden');
            Audio.sfx('levelup');
            setTimeout(() => screen.classList.add('hidden'), 3000);
            this.scene = new PlatformerScene();
            Audio.startMusic(80);
        }
    },

    update(dt) {
        if(!this.scene) return;
        
        this.shiftTime += dt;
        if(this.shake > 0) this.shake -= dt;

        this.scene.update(dt);

        if(this.level === 1 && this.score >= 1000) this.loadLevel(2);
        if(this.level === 2 && this.score >= 2000) this.loadLevel(3);

        this.updateHUD();
    },

    draw() {
        if(!this.scene) return;
        
        this.ctx.save();
        if(this.shake > 0) {
            const dx = (Math.random()-0.5)*10*this.shake;
            const dy = (Math.random()-0.5)*10*this.shake;
            this.ctx.translate(dx, dy);
        }
        
        this.scene.draw(this.ctx);
        this.ctx.restore();

        this.ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
        for (let i = 0; i < this.canvas.height; i += 4) {
            this.ctx.fillRect(0, i, this.canvas.width, 2);
        }
    },

    loop(timestamp) {
        if(!this.lastTime) this.lastTime = timestamp;
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        this.update(dt);
        this.draw();

        requestAnimationFrame((t) => this.loop(t));
    },

    addScore(amount) { this.score += amount; },
    consumeFuel(amount) {
        this.fuel -= amount;
        if(this.fuel <= 0) this.gameOver("OUT OF GAS!");
    },
    refuel() { this.fuel = 100; },
    shake(amount) { this.shake = amount; },

    updateHUD() {
        document.getElementById('hud-score').innerText = `CASH: $${this.score}`;
        const m = Math.floor(this.shiftTime / 60);
        const s = Math.floor(this.shiftTime % 60);
        document.getElementById('hud-time').innerText = `SHIFT: ${m}:${s<10?'0':''}${s}`;
        
        const fill = document.getElementById('fuel-fill');
        fill.style.width = `${Math.max(0, this.fuel)}%`;
        if(this.fuel < 20) fill.classList.add('low');
        else fill.classList.remove('low');
    },

    gameOver(reason) {
        this.scene = null;
        Audio.stopMusic();
        Audio.sfx('crash');
        document.getElementById('end-reason').innerText = reason;
        document.getElementById('end-score').innerText = `EARNINGS: $${this.score}`;
        document.getElementById('screen-gameover').classList.remove('hidden');
    },
    
    win() {
        this.scene = null;
        Audio.stopMusic();
        document.getElementById('win-score').innerText = `$${this.score}`;
        document.getElementById('screen-win').classList.remove('hidden');
    },

    showMenu() {
        this.scene = null;
        Audio.stopMusic();
        this.hideScreens();
        document.getElementById('screen-start').classList.remove('hidden');
    },

    hideScreens() {
        document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden'));
    }
};

window.onload = () => Game.init();

</script>
</body>
</html>
